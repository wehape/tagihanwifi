{"version":3,"sources":["js\\element-internals-polyfill.js"],"names":["refMap","WeakMap","validityMap","hiddenInputMap","internalsMap","validationMessageMap","formsMap","shadowHostsMap","formElementsMap","refValueMap","upgradeMap","shadowRootMap","validationAnchorMap","documentFragmentMap","connectedCallbackMap","validityUpgradeMap","aom","ariaAtomic","ariaAutoComplete","ariaBusy","ariaChecked","ariaColCount","ariaColIndex","ariaColIndexText","ariaColSpan","ariaCurrent","ariaDisabled","ariaExpanded","ariaHasPopup","ariaHidden","ariaInvalid","ariaKeyShortcuts","ariaLabel","ariaLevel","ariaLive","ariaModal","ariaMultiLine","ariaMultiSelectable","ariaOrientation","ariaPlaceholder","ariaPosInSet","ariaPressed","ariaReadOnly","ariaRelevant","ariaRequired","ariaRoleDescription","ariaRowCount","ariaRowIndex","ariaRowIndexText","ariaRowSpan","ariaSelected","ariaSetSize","ariaSort","ariaValueMax","ariaValueMin","ariaValueNow","ariaValueText","role","initNode","node","internals","get","form","initForm","initLabels","labels","walkFieldset","firstRender","walker","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","has","FILTER_ACCEPT","FILTER_SKIP","current","nextNode","isCallNecessary","disabled","formDisabledCallback","setDisabled","disabledOrNameObserverConfig","attributes","attributeFilter","disabledOrNameObserver","mutationObserverExists","MutationObserver","mutationsList","mutation","target","attributeName","constructor","hasAttribute","localName","value","setFormValue","observerCallback","mutationList","forEach","mutationRecord","addedNodes","removedNodes","added","Array","from","removed","Object","keys","filter","key","setAttribute","delete","validity","valid","toString","formElements","observe","removeHiddenInputs","disconnect","fragmentObserverCallback","observer","upgradeInternals","observerConfig","childList","subtree","ref","toggleAttribute","removeAttribute","apply","hiddenInput","remove","set","createHiddenInput","input","createElement","type","name","getAttribute","after","push","length","label","addEventListener","click","bind","firstLabelId","id","htmlFor","setFormValidity","nativeControlValidity","elements","element","tagName","includes","map","polyfilledElements","hasInvalid","control","isConnected","formInputCallback","event","findParentForm","formChangeCallback","formResetCallback","size","formAssociated","add","initSet","Set","submitButtonSelector","sel","join","closest","noValidate","reverse","reportValidity","preventDefault","wireSubmitLogic","formAssociatedCallback","setTimeout","elem","parent","parentNode","throwIfNotFormAssociated","message","ErrorType","DOMException","overrideFormMethod","returnValue","method","ValidityState","this","badInput","customError","patternMismatch","rangeOverflow","rangeUnderflow","stepMismatch","tooLong","tooShort","typeMismatch","valueMissing","seal","isValid","validityState","customStateMap","addState","stateName","part","CustomStateSet","isPolyfilled","super","indexOf","TypeError","state","test","result","clear","entry","entries","__classPrivateFieldGet","receiver","kind","f","call","_HTMLFormControlsCollection_elements","HTMLFormControlsCollection","__classPrivateFieldSet","i","freeze","Symbol","iterator","item","namedItem","ElementInternals","rootNode","getRootNode","states","closureValue","defineProperty","initAom","initRef","DocumentFragment","fragment","deferUpgrade","checkValidity","willValidate","validityEvent","Event","bubbles","cancelable","composed","dispatchEvent","hostRoot","querySelectorAll","anchor","focus","FormData","formDataKey","formDataValue","setValidity","validityChanges","validationMessage","validityChangesObj","validityObject","check","newState","reconcileValidity","shadowRoot","window","HTMLElement","prototype","attachInternals","ElementInternalsFeatureDetection","randomName","Math","random","replace","customElements","define","featureDetectionElement","every","prop","isElementInternalsSupported","args","CustomElementRegistry","options","connectedCallback","Error","Element","attachShadowObserver","attachShadow","ShadyDOM","documentElement","HTMLFormElement","getOwnPropertyDescriptor","orderedElements","concat","sort","a","b","compareDocumentPosition","patchFormPrototype"],"mappings":"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","sourcesContent":["(function () {\n    'use strict';\n\n    const refMap = new WeakMap();\n    const validityMap = new WeakMap();\n    const hiddenInputMap = new WeakMap();\n    const internalsMap = new WeakMap();\n    const validationMessageMap = new WeakMap();\n    const formsMap = new WeakMap();\n    const shadowHostsMap = new WeakMap();\n    const formElementsMap = new WeakMap();\n    const refValueMap = new WeakMap();\n    const upgradeMap = new WeakMap();\n    const shadowRootMap = new WeakMap();\n    const validationAnchorMap = new WeakMap();\n    const documentFragmentMap = new WeakMap();\n    const connectedCallbackMap = new WeakMap();\n    const validityUpgradeMap = new WeakMap();\n\n    const aom = {\n        ariaAtomic: 'aria-atomic',\n        ariaAutoComplete: 'aria-autocomplete',\n        ariaBusy: 'aria-busy',\n        ariaChecked: 'aria-checked',\n        ariaColCount: 'aria-colcount',\n        ariaColIndex: 'aria-colindex',\n        ariaColIndexText: 'aria-colindextext',\n        ariaColSpan: 'aria-colspan',\n        ariaCurrent: 'aria-current',\n        ariaDisabled: 'aria-disabled',\n        ariaExpanded: 'aria-expanded',\n        ariaHasPopup: 'aria-haspopup',\n        ariaHidden: 'aria-hidden',\n        ariaInvalid: 'aria-invalid',\n        ariaKeyShortcuts: 'aria-keyshortcuts',\n        ariaLabel: 'aria-label',\n        ariaLevel: 'aria-level',\n        ariaLive: 'aria-live',\n        ariaModal: 'aria-modal',\n        ariaMultiLine: 'aria-multiline',\n        ariaMultiSelectable: 'aria-multiselectable',\n        ariaOrientation: 'aria-orientation',\n        ariaPlaceholder: 'aria-placeholder',\n        ariaPosInSet: 'aria-posinset',\n        ariaPressed: 'aria-pressed',\n        ariaReadOnly: 'aria-readonly',\n        ariaRelevant: 'aria-relevant',\n        ariaRequired: 'aria-required',\n        ariaRoleDescription: 'aria-roledescription',\n        ariaRowCount: 'aria-rowcount',\n        ariaRowIndex: 'aria-rowindex',\n        ariaRowIndexText: 'aria-rowindextext',\n        ariaRowSpan: 'aria-rowspan',\n        ariaSelected: 'aria-selected',\n        ariaSetSize: 'aria-setsize',\n        ariaSort: 'aria-sort',\n        ariaValueMax: 'aria-valuemax',\n        ariaValueMin: 'aria-valuemin',\n        ariaValueNow: 'aria-valuenow',\n        ariaValueText: 'aria-valuetext',\n        role: 'role'\n    };\n    const initAom = (ref, internals) => {\n        for (let key in aom) {\n            internals[key] = null;\n            let closureValue = null;\n            const attributeName = aom[key];\n            Object.defineProperty(internals, key, {\n                get() {\n                    return closureValue;\n                },\n                set(value) {\n                    closureValue = value;\n                    if (ref.isConnected) {\n                        ref.setAttribute(attributeName, value);\n                    }\n                    else {\n                        upgradeMap.set(ref, internals);\n                    }\n                }\n            });\n        }\n    };\n\n    function initNode(node) {\n        const internals = internalsMap.get(node);\n        const { form } = internals;\n        initForm(node, form, internals);\n        initLabels(node, internals.labels);\n    }\n    const walkFieldset = (node, firstRender = false) => {\n        const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, {\n            acceptNode(node) {\n                return internalsMap.has(node) ?\n                    NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n            }\n        });\n        let current = walker.nextNode();\n        const isCallNecessary = (!firstRender || node.disabled);\n        while (current) {\n            if (current.formDisabledCallback && isCallNecessary) {\n                setDisabled(current, node.disabled);\n            }\n            current = walker.nextNode();\n        }\n    };\n    const disabledOrNameObserverConfig = { attributes: true, attributeFilter: ['disabled', 'name'] };\n    const disabledOrNameObserver = mutationObserverExists() ? new MutationObserver((mutationsList) => {\n        for (const mutation of mutationsList) {\n            const target = mutation.target;\n            if (mutation.attributeName === 'disabled') {\n                if (target.constructor['formAssociated']) {\n                    setDisabled(target, target.hasAttribute('disabled'));\n                }\n                else if (target.localName === 'fieldset') {\n                    walkFieldset(target);\n                }\n            }\n            if (mutation.attributeName === 'name') {\n                if (target.constructor['formAssociated']) {\n                    const internals = internalsMap.get(target);\n                    const value = refValueMap.get(target);\n                    internals.setFormValue(value);\n                }\n            }\n        }\n    }) : {};\n    function observerCallback(mutationList) {\n        mutationList.forEach(mutationRecord => {\n            const { addedNodes, removedNodes } = mutationRecord;\n            const added = Array.from(addedNodes);\n            const removed = Array.from(removedNodes);\n            added.forEach(node => {\n                if (internalsMap.has(node) && node.constructor['formAssociated']) {\n                    initNode(node);\n                }\n                if (upgradeMap.has(node)) {\n                    const internals = upgradeMap.get(node);\n                    const aomKeys = Object.keys(aom);\n                    aomKeys\n                        .filter(key => internals[key] !== null)\n                        .forEach(key => {\n                        node.setAttribute(aom[key], internals[key]);\n                    });\n                    upgradeMap.delete(node);\n                }\n                if (validityUpgradeMap.has(node)) {\n                    const internals = validityUpgradeMap.get(node);\n                    node.setAttribute('internals-valid', internals.validity.valid.toString());\n                    node.setAttribute('internals-invalid', (!internals.validity.valid).toString());\n                    node.setAttribute('aria-invalid', (!internals.validity.valid).toString());\n                    validityUpgradeMap.delete(node);\n                }\n                if (node.localName === 'form') {\n                    const formElements = formElementsMap.get(node);\n                    const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, {\n                        acceptNode(node) {\n                            return internalsMap.has(node) && !(formElements && formElements.has(node)) ?\n                                NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n                        }\n                    });\n                    let current = walker.nextNode();\n                    while (current) {\n                        initNode(current);\n                        current = walker.nextNode();\n                    }\n                }\n                if (node.localName === 'fieldset') {\n                    disabledOrNameObserver.observe?.(node, disabledOrNameObserverConfig);\n                    walkFieldset(node, true);\n                }\n            });\n            removed.forEach(node => {\n                const internals = internalsMap.get(node);\n                if (internals && hiddenInputMap.get(internals)) {\n                    removeHiddenInputs(internals);\n                }\n                if (shadowHostsMap.has(node)) {\n                    const observer = shadowHostsMap.get(node);\n                    observer.disconnect();\n                }\n            });\n        });\n    }\n    function fragmentObserverCallback(mutationList) {\n        mutationList.forEach(mutation => {\n            const { removedNodes } = mutation;\n            removedNodes.forEach(node => {\n                const observer = documentFragmentMap.get(mutation.target);\n                if (internalsMap.has(node)) {\n                    upgradeInternals(node);\n                }\n                observer.disconnect();\n            });\n        });\n    }\n    const deferUpgrade = (fragment) => {\n        const observer = new MutationObserver(fragmentObserverCallback);\n        observer.observe?.(fragment, { childList: true });\n        documentFragmentMap.set(fragment, observer);\n    };\n    mutationObserverExists() ? new MutationObserver(observerCallback) : {};\n    const observerConfig = {\n        childList: true,\n        subtree: true\n    };\n\n    const setDisabled = (ref, disabled) => {\n        ref.toggleAttribute('internals-disabled', disabled);\n        if (disabled) {\n            ref.setAttribute('aria-disabled', 'true');\n        }\n        else {\n            ref.removeAttribute('aria-disabled');\n        }\n        if (ref.formDisabledCallback) {\n            ref.formDisabledCallback.apply(ref, [disabled]);\n        }\n    };\n    const removeHiddenInputs = (internals) => {\n        const hiddenInputs = hiddenInputMap.get(internals);\n        hiddenInputs.forEach(hiddenInput => {\n            hiddenInput.remove();\n        });\n        hiddenInputMap.set(internals, []);\n    };\n    const createHiddenInput = (ref, internals) => {\n        const input = document.createElement('input');\n        input.type = 'hidden';\n        input.name = ref.getAttribute('name');\n        ref.after(input);\n        hiddenInputMap.get(internals).push(input);\n        return input;\n    };\n    const initRef = (ref, internals) => {\n        hiddenInputMap.set(internals, []);\n        disabledOrNameObserver.observe?.(ref, disabledOrNameObserverConfig);\n    };\n    const initLabels = (ref, labels) => {\n        if (labels.length) {\n            Array.from(labels).forEach(label => label.addEventListener('click', ref.click.bind(ref)));\n            let firstLabelId = labels[0].id;\n            if (!labels[0].id) {\n                firstLabelId = `${labels[0].htmlFor}_Label`;\n                labels[0].id = firstLabelId;\n            }\n            ref.setAttribute('aria-labelledby', firstLabelId);\n        }\n    };\n    const setFormValidity = (form) => {\n        const nativeControlValidity = Array.from(form.elements)\n            .filter((element) => !element.tagName.includes('-') && element.validity)\n            .map((element) => element.validity.valid);\n        const polyfilledElements = formElementsMap.get(form) || [];\n        const polyfilledValidity = Array.from(polyfilledElements)\n            .filter(control => control.isConnected)\n            .map((control) => internalsMap.get(control).validity.valid);\n        const hasInvalid = [...nativeControlValidity, ...polyfilledValidity].includes(false);\n        form.toggleAttribute('internals-invalid', hasInvalid);\n        form.toggleAttribute('internals-valid', !hasInvalid);\n    };\n    const formInputCallback = (event) => {\n        setFormValidity(findParentForm(event.target));\n    };\n    const formChangeCallback = (event) => {\n        setFormValidity(findParentForm(event.target));\n    };\n    const wireSubmitLogic = (form) => {\n        const submitButtonSelector = ['button[type=submit]', 'input[type=submit]', 'button:not([type])']\n            .map(sel => `${sel}:not([disabled])`)\n            .map(sel => `${sel}:not([form])${form.id ? `,${sel}[form='${form.id}']` : ''}`)\n            .join(',');\n        form.addEventListener('click', event => {\n            const target = event.target;\n            if (target.closest(submitButtonSelector)) {\n                const elements = formElementsMap.get(form);\n                if (form.noValidate) {\n                    return;\n                }\n                if (elements.size) {\n                    const nodes = Array.from(elements);\n                    const validityList = nodes\n                        .reverse()\n                        .map(node => {\n                        const internals = internalsMap.get(node);\n                        return internals.reportValidity();\n                    });\n                    if (validityList.includes(false)) {\n                        event.preventDefault();\n                    }\n                }\n            }\n        });\n    };\n    const formResetCallback = (event) => {\n        const elements = formElementsMap.get(event.target);\n        if (elements && elements.size) {\n            elements.forEach(element => {\n                if (element.constructor.formAssociated && element.formResetCallback) {\n                    element.formResetCallback.apply(element);\n                }\n            });\n        }\n    };\n    const initForm = (ref, form, internals) => {\n        if (form) {\n            const formElements = formElementsMap.get(form);\n            if (formElements) {\n                formElements.add(ref);\n            }\n            else {\n                const initSet = new Set();\n                initSet.add(ref);\n                formElementsMap.set(form, initSet);\n                wireSubmitLogic(form);\n                form.addEventListener('reset', formResetCallback);\n                form.addEventListener('input', formInputCallback);\n                form.addEventListener('change', formChangeCallback);\n            }\n            formsMap.set(form, { ref, internals });\n            if (ref.constructor['formAssociated'] && ref.formAssociatedCallback) {\n                setTimeout(() => {\n                    ref.formAssociatedCallback.apply(ref, [form]);\n                }, 0);\n            }\n            setFormValidity(form);\n        }\n    };\n    const findParentForm = (elem) => {\n        let parent = elem.parentNode;\n        if (parent && parent.tagName !== 'FORM') {\n            parent = findParentForm(parent);\n        }\n        return parent;\n    };\n    const throwIfNotFormAssociated = (ref, message, ErrorType = DOMException) => {\n        if (!ref.constructor['formAssociated']) {\n            throw new ErrorType(message);\n        }\n    };\n    const overrideFormMethod = (form, returnValue, method) => {\n        const elements = formElementsMap.get(form);\n        if (elements && elements.size) {\n            elements.forEach(element => {\n                const internals = internalsMap.get(element);\n                const valid = internals[method]();\n                if (!valid) {\n                    returnValue = false;\n                }\n            });\n        }\n        return returnValue;\n    };\n    const upgradeInternals = (ref) => {\n        if (ref.constructor['formAssociated']) {\n            const internals = internalsMap.get(ref);\n            const { labels, form } = internals;\n            initLabels(ref, labels);\n            initForm(ref, form, internals);\n        }\n    };\n    function mutationObserverExists() {\n        return typeof MutationObserver !== 'undefined';\n    }\n\n    class ValidityState {\n        constructor() {\n            this.badInput = false;\n            this.customError = false;\n            this.patternMismatch = false;\n            this.rangeOverflow = false;\n            this.rangeUnderflow = false;\n            this.stepMismatch = false;\n            this.tooLong = false;\n            this.tooShort = false;\n            this.typeMismatch = false;\n            this.valid = true;\n            this.valueMissing = false;\n            Object.seal(this);\n        }\n    }\n    const setValid = (validityObject) => {\n        validityObject.badInput = false;\n        validityObject.customError = false;\n        validityObject.patternMismatch = false;\n        validityObject.rangeOverflow = false;\n        validityObject.rangeUnderflow = false;\n        validityObject.stepMismatch = false;\n        validityObject.tooLong = false;\n        validityObject.tooShort = false;\n        validityObject.typeMismatch = false;\n        validityObject.valid = true;\n        validityObject.valueMissing = false;\n        return validityObject;\n    };\n    const reconcileValidity = (validityObject, newState, form) => {\n        validityObject.valid = isValid(newState);\n        Object.keys(newState).forEach(key => validityObject[key] = newState[key]);\n        if (form) {\n            setFormValidity(form);\n        }\n        return validityObject;\n    };\n    const isValid = (validityState) => {\n        let valid = true;\n        for (let key in validityState) {\n            if (key !== 'valid' && validityState[key] !== false) {\n                valid = false;\n            }\n        }\n        return valid;\n    };\n\n    const customStateMap = new WeakMap();\n    function addState(ref, stateName) {\n        ref.toggleAttribute(stateName, true);\n        if (ref.part) {\n            ref.part.add(stateName);\n        }\n    }\n    class CustomStateSet extends Set {\n        static get isPolyfilled() {\n            return true;\n        }\n        constructor(ref) {\n            super();\n            if (!ref || !ref.tagName || ref.tagName.indexOf('-') === -1) {\n                throw new TypeError('Illegal constructor');\n            }\n            customStateMap.set(this, ref);\n        }\n        add(state) {\n            if (!/^--/.test(state) || typeof state !== 'string') {\n                throw new DOMException(`Failed to execute 'add' on 'CustomStateSet': The specified value ${state} must start with '--'.`);\n            }\n            const result = super.add(state);\n            const ref = customStateMap.get(this);\n            const stateName = `state${state}`;\n            if (ref.isConnected) {\n                addState(ref, stateName);\n            }\n            else {\n                setTimeout(() => {\n                    addState(ref, stateName);\n                });\n            }\n            return result;\n        }\n        clear() {\n            for (let [entry] of this.entries()) {\n                this.delete(entry);\n            }\n            super.clear();\n        }\n        delete(state) {\n            const result = super.delete(state);\n            const ref = customStateMap.get(this);\n            if (ref.isConnected) {\n                ref.toggleAttribute(`state${state}`, false);\n                if (ref.part) {\n                    ref.part.remove(`state${state}`);\n                }\n            }\n            else {\n                setTimeout(() => {\n                    ref.toggleAttribute(`state${state}`, false);\n                    if (ref.part) {\n                        ref.part.remove(`state${state}`);\n                    }\n                });\n            }\n            return result;\n        }\n    }\n\n    function __classPrivateFieldGet(receiver, state, kind, f) {\n        if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n        if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n        return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n    }\n    function __classPrivateFieldSet(receiver, state, value, kind, f) {\n        if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n        if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n        if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n        return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n    }\n\n    var _HTMLFormControlsCollection_elements;\n    class HTMLFormControlsCollection {\n        constructor(elements) {\n            _HTMLFormControlsCollection_elements.set(this, void 0);\n            __classPrivateFieldSet(this, _HTMLFormControlsCollection_elements, elements, \"f\");\n            for (let i = 0; i < elements.length; i++) {\n                let element = elements[i];\n                this[i] = element;\n                if (element.hasAttribute('name')) {\n                    this[element.getAttribute('name')] = element;\n                }\n            }\n            Object.freeze(this);\n        }\n        get length() {\n            return __classPrivateFieldGet(this, _HTMLFormControlsCollection_elements, \"f\").length;\n        }\n        [(_HTMLFormControlsCollection_elements = new WeakMap(), Symbol.iterator)]() {\n            return __classPrivateFieldGet(this, _HTMLFormControlsCollection_elements, \"f\")[Symbol.iterator]();\n        }\n        item(i) {\n            return this[i] == null ? null : this[i];\n        }\n        namedItem(name) {\n            return this[name] == null ? null : this[name];\n        }\n    }\n\n    function patchFormPrototype() {\n        const checkValidity = HTMLFormElement.prototype.checkValidity;\n        HTMLFormElement.prototype.checkValidity = checkValidityOverride;\n        const reportValidity = HTMLFormElement.prototype.reportValidity;\n        HTMLFormElement.prototype.reportValidity = reportValidityOverride;\n        function checkValidityOverride(...args) {\n            let returnValue = checkValidity.apply(this, args);\n            return overrideFormMethod(this, returnValue, 'checkValidity');\n        }\n        function reportValidityOverride(...args) {\n            let returnValue = reportValidity.apply(this, args);\n            return overrideFormMethod(this, returnValue, 'reportValidity');\n        }\n        const { get } = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, 'elements');\n        Object.defineProperty(HTMLFormElement.prototype, 'elements', {\n            get(...args) {\n                const elements = get.call(this, ...args);\n                const polyfilledElements = Array.from(formElementsMap.get(this) || []);\n                if (polyfilledElements.length === 0) {\n                    return elements;\n                }\n                const orderedElements = Array.from(elements).concat(polyfilledElements).sort((a, b) => {\n                    if (a.compareDocumentPosition) {\n                        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n                    }\n                    return 0;\n                });\n                return new HTMLFormControlsCollection(orderedElements);\n            },\n        });\n    }\n\n    class ElementInternals {\n        static get isPolyfilled() {\n            return true;\n        }\n        constructor(ref) {\n            if (!ref || !ref.tagName || ref.tagName.indexOf('-') === -1) {\n                throw new TypeError('Illegal constructor');\n            }\n            const rootNode = ref.getRootNode();\n            const validity = new ValidityState();\n            this.states = new CustomStateSet(ref);\n            refMap.set(this, ref);\n            validityMap.set(this, validity);\n            internalsMap.set(ref, this);\n            initAom(ref, this);\n            initRef(ref, this);\n            Object.seal(this);\n            if (rootNode instanceof DocumentFragment) {\n                deferUpgrade(rootNode);\n            }\n        }\n        checkValidity() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to execute 'checkValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);\n            if (!this.willValidate) {\n                return true;\n            }\n            const validity = validityMap.get(this);\n            if (!validity.valid) {\n                const validityEvent = new Event('invalid', {\n                    bubbles: false,\n                    cancelable: true,\n                    composed: false\n                });\n                ref.dispatchEvent(validityEvent);\n            }\n            return validity.valid;\n        }\n        get form() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to read the 'form' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n            let form;\n            if (ref.constructor['formAssociated'] === true) {\n                form = findParentForm(ref);\n            }\n            return form;\n        }\n        get labels() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to read the 'labels' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n            const id = ref.getAttribute('id');\n            const hostRoot = ref.getRootNode();\n            if (hostRoot && id) {\n                return hostRoot.querySelectorAll(`[for=\"${id}\"]`);\n            }\n            return [];\n        }\n        reportValidity() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to execute 'reportValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);\n            if (!this.willValidate) {\n                return true;\n            }\n            const valid = this.checkValidity();\n            const anchor = validationAnchorMap.get(this);\n            if (anchor && !ref.constructor['formAssociated']) {\n                throw new DOMException(`Failed to execute 'reportValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);\n            }\n            if (!valid && anchor) {\n                ref.focus();\n                anchor.focus();\n            }\n            return valid;\n        }\n        setFormValue(value) {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to execute 'setFormValue' on 'ElementInternals': The target element is not a form-associated custom element.`);\n            removeHiddenInputs(this);\n            if (value != null && !(value instanceof FormData)) {\n                if (ref.getAttribute('name')) {\n                    const hiddenInput = createHiddenInput(ref, this);\n                    hiddenInput.value = value;\n                }\n            }\n            else if (value != null && value instanceof FormData) {\n                Array.from(value).reverse().forEach(([formDataKey, formDataValue]) => {\n                    if (typeof formDataValue === 'string') {\n                        const hiddenInput = createHiddenInput(ref, this);\n                        hiddenInput.name = formDataKey;\n                        hiddenInput.value = formDataValue;\n                    }\n                });\n            }\n            refValueMap.set(ref, value);\n        }\n        setValidity(validityChanges, validationMessage, anchor) {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to execute 'setValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);\n            if (!validityChanges) {\n                throw new TypeError('Failed to execute \\'setValidity\\' on \\'ElementInternals\\': 1 argument required, but only 0 present.');\n            }\n            validationAnchorMap.set(this, anchor);\n            const validity = validityMap.get(this);\n            const validityChangesObj = {};\n            for (const key in validityChanges) {\n                validityChangesObj[key] = validityChanges[key];\n            }\n            if (Object.keys(validityChangesObj).length === 0) {\n                setValid(validity);\n            }\n            const check = { ...validity, ...validityChangesObj };\n            delete check.valid;\n            const { valid } = reconcileValidity(validity, check, this.form);\n            if (!valid && !validationMessage) {\n                throw new DOMException(`Failed to execute 'setValidity' on 'ElementInternals': The second argument should not be empty if one or more flags in the first argument are true.`);\n            }\n            validationMessageMap.set(this, valid ? '' : validationMessage);\n            if (ref.isConnected) {\n                ref.toggleAttribute('internals-invalid', !valid);\n                ref.toggleAttribute('internals-valid', valid);\n                ref.setAttribute('aria-invalid', `${!valid}`);\n            }\n            else {\n                validityUpgradeMap.set(ref, this);\n            }\n        }\n        get shadowRoot() {\n            const ref = refMap.get(this);\n            const shadowRoot = shadowRootMap.get(ref);\n            if (shadowRoot) {\n                return shadowRoot;\n            }\n            return null;\n        }\n        get validationMessage() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to read the 'validationMessage' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n            return validationMessageMap.get(this);\n        }\n        get validity() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to read the 'validity' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n            const validity = validityMap.get(this);\n            return validity;\n        }\n        get willValidate() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to read the 'willValidate' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n            if ((ref.disabled || ref.hasAttribute('disabled')) ||\n                ref.hasAttribute('readonly')) {\n                return false;\n            }\n            return true;\n        }\n    }\n    function isElementInternalsSupported() {\n        if (typeof window === 'undefined' || !window.ElementInternals || !HTMLElement.prototype.attachInternals) {\n            return false;\n        }\n        class ElementInternalsFeatureDetection extends HTMLElement {\n            constructor() {\n                super();\n                this.internals = this.attachInternals();\n            }\n        }\n        const randomName = `element-internals-feature-detection-${Math.random().toString(36).replace(/[^a-z]+/g, '')}`;\n        customElements.define(randomName, ElementInternalsFeatureDetection);\n        const featureDetectionElement = new ElementInternalsFeatureDetection();\n        return [\n            'shadowRoot',\n            'form',\n            'willValidate',\n            'validity',\n            'validationMessage',\n            'labels',\n            'setFormValue',\n            'setValidity',\n            'checkValidity',\n            'reportValidity'\n        ].every(prop => prop in featureDetectionElement.internals);\n    }\n    if (!isElementInternalsSupported()) {\n        if (typeof window !== 'undefined') {\n            window.ElementInternals = ElementInternals;\n        }\n        if (typeof CustomElementRegistry !== 'undefined') {\n            const define = CustomElementRegistry.prototype.define;\n            CustomElementRegistry.prototype.define = function (name, constructor, options) {\n                if (constructor.formAssociated) {\n                    const connectedCallback = constructor.prototype.connectedCallback;\n                    constructor.prototype.connectedCallback = function () {\n                        if (!connectedCallbackMap.has(this)) {\n                            connectedCallbackMap.set(this, true);\n                            if (this.hasAttribute('disabled')) {\n                                setDisabled(this, true);\n                            }\n                        }\n                        if (connectedCallback != null) {\n                            connectedCallback.apply(this);\n                        }\n                        upgradeInternals(this);\n                    };\n                }\n                define.call(this, name, constructor, options);\n            };\n        }\n        if (typeof HTMLElement !== 'undefined') {\n            HTMLElement.prototype.attachInternals = function () {\n                if (!this.tagName) {\n                    return {};\n                }\n                else if (this.tagName.indexOf('-') === -1) {\n                    throw new Error(`Failed to execute 'attachInternals' on 'HTMLElement': Unable to attach ElementInternals to non-custom elements.`);\n                }\n                if (internalsMap.has(this)) {\n                    throw new DOMException(`DOMException: Failed to execute 'attachInternals' on 'HTMLElement': ElementInternals for the specified element was already attached.`);\n                }\n                return new ElementInternals(this);\n            };\n        }\n        if (typeof Element !== 'undefined') {\n            function attachShadowObserver(...args) {\n                const shadowRoot = attachShadow.apply(this, args);\n                shadowRootMap.set(this, shadowRoot);\n                if (mutationObserverExists()) {\n                    const observer = new MutationObserver(observerCallback);\n                    if (window.ShadyDOM) {\n                        observer.observe(this, observerConfig);\n                    }\n                    else {\n                        observer.observe(shadowRoot, observerConfig);\n                    }\n                    shadowHostsMap.set(this, observer);\n                }\n                return shadowRoot;\n            }\n            const attachShadow = Element.prototype.attachShadow;\n            Element.prototype.attachShadow = attachShadowObserver;\n        }\n        if (mutationObserverExists()) {\n            const documentObserver = new MutationObserver(observerCallback);\n            documentObserver.observe(document.documentElement, observerConfig);\n        }\n        if (typeof HTMLFormElement !== 'undefined') {\n            patchFormPrototype();\n        }\n        if (typeof window !== 'undefined' && !window.CustomStateSet) {\n            window.CustomStateSet = CustomStateSet;\n        }\n    }\n    else if (typeof window !== 'undefined' && !window.CustomStateSet) {\n        window.CustomStateSet = CustomStateSet;\n        const attachInternals = HTMLElement.prototype.attachInternals;\n        HTMLElement.prototype.attachInternals = function (...args) {\n            const internals = attachInternals.call(this, args);\n            internals.states = new CustomStateSet(this);\n            return internals;\n        };\n    }\n\n})();\n"]}